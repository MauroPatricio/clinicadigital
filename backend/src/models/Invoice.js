import mongoose from 'mongoose';

const InvoiceSchema = new mongoose.Schema({
    invoiceNumber: {
        type: String,
        required: true,
        unique: true
    },
    patient: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Patient',
        required: true
    },
    clinic: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Clinic',
        required: true
    },
    billReference: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Bill'
    },

    // Invoice Details
    issueDate: {
        type: Date,
        default: Date.now
    },
    dueDate: {
        type: Date,
        required: true
    },
    items: [{
        description: { type: String, required: true },
        quantity: { type: Number, default: 1 },
        unitPrice: { type: Number, required: true },
        total: { type: Number, required: true }
    }],

    // Amounts
    subtotal: {
        type: Number,
        required: true
    },
    tax: {
        type: Number,
        default: 0
    },
    discount: {
        type: Number,
        default: 0
    },
    totalAmount: {
        type: Number,
        required: true
    },

    // Payment
    paymentStatus: {
        type: String,
        enum: ['pending', 'partial', 'paid', 'overdue'],
        default: 'pending'
    },
    paidAmount: {
        type: Number,
        default: 0
    },
    payments: [{
        date: { type: Date, required: true },
        amount: { type: Number, required: true },
        method: { type: String, required: true },
        reference: String,
        notes: String
    }],

    // Insurance
    insuranceProvider: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'InsuranceProvider'
    },
    insuranceCoverage: {
        type: Number,
        default: 0
    },
    patientResponsibility: {
        type: Number
    },

    // Status
    status: {
        type: String,
        enum: ['draft', 'sent', 'viewed', 'paid', 'cancelled'],
        default: 'draft'
    },
    sentDate: Date,
    viewedDate: Date,

    // Auto-generation
    isAutoGenerated: {
        type: Boolean,
        default: false
    },
    generatedFrom: {
        type: String,
        enum: ['bill', 'appointment', 'recurring_payment', 'manual'],
        default: 'manual'
    },

    notes: String,
    attachments: [String],
    metadata: mongoose.Schema.Types.Mixed
}, {
    timestamps: true
});

// Indexes
InvoiceSchema.index({ invoiceNumber: 1 });
InvoiceSchema.index({ patient: 1, issueDate: -1 });
InvoiceSchema.index({ clinic: 1, status: 1 });
InvoiceSchema.index({ paymentStatus: 1, dueDate: 1 });

// Auto-generate invoice number
InvoiceSchema.pre('save', async function (next) {
    if (!this.invoiceNumber) {
        const year = new Date().getFullYear();
        const month = String(new Date().getMonth() + 1).padStart(2, '0');
        const count = await this.constructor.countDocuments({
            invoiceNumber: new RegExp(`^INV-${year}${month}`)
        });
        this.invoiceNumber = `INV-${year}${month}-${String(count + 1).padStart(4, '0')}`;
    }

    // Calculate patient responsibility
    if (this.insuranceCoverage) {
        this.patientResponsibility = this.totalAmount - this.insuranceCoverage;
    } else {
        this.patientResponsibility = this.totalAmount;
    }

    // Update payment status based on paid amount
    if (this.paidAmount >= this.totalAmount) {
        this.paymentStatus = 'paid';
        this.status = 'paid';
    } else if (this.paidAmount > 0) {
        this.paymentStatus = 'partial';
    } else if (this.dueDate < new Date() && this.paymentStatus !== 'paid') {
        this.paymentStatus = 'overdue';
    }

    next();
});

// Static Methods

// Get invoice statistics
InvoiceSchema.statics.getStats = async function (startDate, endDate, filters = {}) {
    const query = { issueDate: { $gte: startDate, $lte: endDate }, ...filters };

    const stats = await this.aggregate([
        { $match: query },
        {
            $group: {
                _id: null,
                totalInvoices: { $sum: 1 },
                totalAmount: { $sum: '$totalAmount' },
                totalPaid: { $sum: '$paidAmount' },
                avgAmount: { $avg: '$totalAmount' }
            }
        }
    ]);

    const byStatus = await this.aggregate([
        { $match: query },
        {
            $group: {
                _id: '$paymentStatus',
                count: { $sum: 1 },
                amount: { $sum: '$totalAmount' }
            }
        }
    ]);

    return {
        summary: stats[0] || { totalInvoices: 0, totalAmount: 0, totalPaid: 0, avgAmount: 0 },
        byStatus
    };
};

// Record payment
InvoiceSchema.methods.recordPayment = async function (amount, method, reference, notes) {
    this.payments.push({
        date: new Date(),
        amount,
        method,
        reference,
        notes
    });

    this.paidAmount += amount;
    await this.save();

    return this;
};

// Mark as sent
InvoiceSchema.methods.markAsSent = async function () {
    this.status = 'sent';
    this.sentDate = new Date();
    await this.save();
    return this;
};

// Mark as viewed
InvoiceSchema.methods.markAsViewed = async function () {
    if (this.status === 'sent') {
        this.status = 'viewed';
        this.viewedDate = new Date();
        await this.save();
    }
    return this;
};

export default mongoose.model('Invoice', InvoiceSchema);
